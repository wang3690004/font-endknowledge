####原型，原型链，继承
在javascript中原型，原型链，继承也算是比较难理解的一部分了。大大小小也学习了几次。这次决定再次系统性的学习它。
#####原型
1.对象是键/值对。创建对象的最常用方法是使用花括号{}，并使用点来表示向对象添加属性和方法
> let animal={};
animal.name = 'leo';
animal.eat= function(amount){
    console.log(amount)
}

现在在我们的应用程序中，我们需要创建多个animal，当然下一步是将逻辑封装，当我们需要创建新的animal的时候只需要调用函数即可，我们将这种模式成为 函数实例化。我们这时候便成函数的本身为构造函数，因为他负责构造一个对象
2.函数的实例化
> function animal(name,energy){
    let animal={}
    animal.name = name;
    animal.energy = energy
    animal.eat = function(amount){
        console.log(amount)
    }
    return animal
}
const leo = animal('leo',7)

现在无论如何我们想要创建一个新animal（创建一个实例），我们所要做的就是调用我们的animal函数并传入参数name和energy，着很有用，而且非常简单，但是这种模式有一个缺点啊，就是创建出来的实例他们的方法都是一模一样的，即使我用不到某个方法，这样做会浪费内存的。有一种好的办法就是让所有的实例共用这一个方法，这样又节省了内存 也省心，我们可以称此模式为 函数实例化共享方法

3.函数实例化共享方法
>const animalmethods={
    eat(amount){
        console.log(amount)
    }
}
function animal(name,energy){
    let animal = {}
    animal.name = name;
    animal.energy =energy
    animal.eat = animalmethods.eat(运用对象的引用，让实例化出来的对象都可以用animalmethod的方法)
    return animal
}
const leo = animal('leo',7),通过共享方法移动到他们自己的对象，并在animal函数中引用该对象，我们已经解决了内存浪费和新对象体积过大的问题。

4.Object.create
让我们用object.create改进这个例子，简单来说，object.create 允许你创建一个对象，该对象在失败的查找后会将查找委托给参数中的继续查找。
> const parent={
    name:'aaa',
    age:35,
}
 const child = Object.create(parent)
 child.name='bbb'
 console.log(child.name) //bbb
 console.log(child.age) //35
console.log(child) // {name:'bbb'}
 
 由于child是由object.create(parent)创建的，所以当child对象上的属性查找失败时，js会委托给parent对象，即使child没有age也无所谓，所以打印age会出来35.这里面其实会涉及到原型的部分 在后面会详细解释
 现在使用object.create来优化这个方法
 >const animalmethod = {
     eat(amount){
         console.log(amount)
     }
 }
 function animal(eat,energy){
     let animal = object.create(animalmethod)//让animal实例使用animalmethod的实例
     animal.name = name
     animal.energy = energy;
     return animal
 }
 const leo=animal('leo',7)
 leo.eat(10)

 所以在调用leo.eat时候，js会在leo对象上找eat方法，找不到，所以会去找animalmethod的对象，所以可以找到
 尽管如此还有一个问题，就是为了跨实例共享方法，我们还要单独引入一个对象来管理这些方法，会不会有点太麻烦了，所以我们直接给用来构建对象的构造函数一个属性prototype，让他们直接用构造函数的方法不就完事了。
 >function a(){}
 a.ptototype // {}

 5.原型实例化
 >function animal(name,energy){
     let animal = object.create(animal.prototype)
     animal.name =name
     animal.energy = energy
     return animal
 }
 animal.prototype.eat= function(amount){
     conosle.log(amount)
 }
 const leo = animal('leo',7)
 leo.eat(10)

同样的prototype只是js中的每一个函数都具有的属性，正如我们前面看到的，它允许我们跨函数的所有实例共享方法，我们所有的功能仍然是相同的，但是我们现在不用为所有的方法管理一个单独的对象，只需要用animal。prototype

6.new
在js中有个new方法 这个方法可以将编号为1 和2 的代码在底层帮助你完成，
>function animal(name,energy){
    let animal = object.create(animal.prototype) //1
    ....
    return animal //2
}

看起来就像是专门为了构造一个实例对象而设计的有木有，new方法的应用
>function animal(name,energy){
    this.name = name
    this.energy = energy
}
animal.ptototype.eat=function(amount){
    console.log(amount)
}
const leo=new animal('leo',8)
注意这个new的方法必须要声明，不如无法创建对象。

ES6中新创建了一个类的概念，它的理念使js更像是面向对象的语言了，虽然本质上还是用function。。。。
>class animal{
    constructor(name,energy){
        this.name = name
        this.energy = energy
    }
    eat(amount){
        console.log(amount)
    }
}
const leo = new animal('leo',7)
这不仅让我想到了react用类来创建的方法，react这样用具体想用来干什么呢？

7.数组方法
当我们使用let test= [] 的时候其实在底层相当于使用了 test = new Array()
不然我们什么方法都没有添加为什么还会有又各种数组的方法，因为这些数组方法存在于Array。prototype中
我们创建了实例自然可以在array.prototype中找到了。

8.静态方法 static
到目前为止，存在一种情况如果我们有一个对类很重要的方法，但是不需要在实例之间共享的话要怎么办？如果有一个函数，它接收一系列aniaml实例，并确定下一步需要喂养哪一个呢？
>function nexttoeat(animals){
    const sortedbyleastenergy =animals.sort((a,b)=>return a-b)
    return sortedbyleastenergy[0].name
}
我们不希望所有实例之间共享这个nexttoeat，我们要是放在原型中怕是不行了，可以考虑以一个单独的函数放到外面，
其实还有一个更好的方法，static  将其设置为静态属性。
class animal={
    ....
    static nexttoeat(){
        ...
    }
}

我们在类上添加了nexttoeat 作为静态属性，**当然我们说它为animal的一个明面调用属性听起来更好理解一些**所以它存在animal本身而不是原型上，所以实例不能用
>function animal(name){
    .....
}
animal.nexttoeat=function(nexttoeat){...}

转化为es5就是这样的。

9.获取对象的原型
我们通过类创建出来的实例本身是没有prototype的，其实是通过原型链的方式访问到创建它的构造类函数，所以我们可以使用object.getprototypeof(instance)来获取到它的上一级prototype。这个需要在后面说到。而每一个函数其实都是有prototype这个属性的，他们上一级的prototype其实是指向object的



感谢下面链接的分享：
https://github.com/qq449245884/xiaozhi/issues/60