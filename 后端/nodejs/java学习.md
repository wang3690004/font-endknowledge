数组定义
String [] names = {"1","2","3","4"} 静态定义数组
double [] scores = new double[8] 动态定义数组

构造器
public class Student{
}
//在类中 设置一个方法名与类名一致且不返回任何值，
构造器创建对象时 对象会去调用构造器 创建对象时完成对对象成员变量初始化赋值
类默认自带一个无参数构造器，如果定义了有参构造器，类默认的无参构造器就没有了，此时如果还想用无参构造器 就必须手写一个

this 关键字
this 就是一个变量 可在方法中 来拿到当前的对象
使用场景： 解决变量名称冲突问题

封装 继承 多态
面向对象的三大特征， 类就是一种封装
封装：合理隐藏 合理暴露
private : 关键字修饰成员变量，就只能在本类中被直接访问 其他任何地方不能直接访问

实体类： 类中的成员变量全部私有，并提供 getter setter 方法
类中需要提供一个无参数的构造器 有参数构造器可选
实体类 javabean 的基本作用：
实体类的应用场景： 实体类的对象 只负责数据存取，而对数据业务处理交给其他类的对象来完成，以实现数据和数据业务处理相分离
public clss Student{
name,age,
}

public class StudentOperator{
private Student s;
public StudentOperator(Student s){
this.s = s
}
}

static 关键字 可以修饰成员变量 成员方法
public class Student{
static String name;  
}
成员变量按照有无 static 修饰分为两种
静态变量（类变量）有 static 修饰 属于类变量 在计算机里只有一份 会被类的全部对象共享
实例变量（对象的变量）无 static 修饰 属于每一个对象的但是彼此不共享

static 静态方法 如果这个方法只是为了做一个功能不需要直接访问对象的数据，这个方法直接定义成静态方法
如果这个方法是对象的行为，需要访问对象的数据 这个方法必须定义成实例方法，
常见的应用场景： 工具类，工具类中的方法一般都是静态方法，每个方法都要来完成一个功能以便给开发人员直接使用
静态方法 中可以访问静态变量，但是不能访问实例变量
实例方法中既可以直接访问静态变量，也可以直接访问实例变量
实例方法中可以出现 this 关键字 静态方法中不可以出现 this 关键字

什么是继承
java 中提供了一个关键字 extends 这个可以让一个类和另一个类建立起父子关系， A 成为父类 B 成为子类
public class B extends A{

}
子类能继承父类的非私有成员（成员变量 成员方法）
继承后对象的创建，子类的对象是由子类 父类共同完成的

权限修饰符
private 只能本类
缺省 本类、同一个包中的类
protected 本类、同一个包中的类、子类
public 所有
使用标准， 一般的成员变量 一般都是使用 private 方法一般都会 public 至于缺省 protected 根据业务需求

java 单继承 只能有一个父类 不支持多继承，但是支持多层继承，如 爷 父 子类

java 类为什么不支持多继承 如果一个子类 又继承了 A 又继承了 B 都是父类 如果两个父类都有同一个方法 那么子类调用这个方法的时候就无法确定调用的是哪个父类的方法 所以不支持多继承

java 中的祖宗类 Object， java 所有的类 要么直接继承了 Object 要不默认继承了 object 要么间接继承了 object，

继承后子类访问成员的特点 ：就近原则 子类中如果有同名成员变量，访问子类中同名成员变量，如果没有同名成员变量，访问父类中同名成员变量
可以使用 super 关键字 访问父类的成员 super.成员变量 super.方法名

方法重写： 当子类觉得父类中的某个方法不好用 可以重写这个方法，参数列表一样的方法去覆盖父类的这个方法 就是方法重写，最好给方法重写添加一个 注解 @Override 告诉别人这是个重写的方法 要求方法名称 形参 必须和被重写的方法一致
需要注意的是 子类重写父类方法时 访问权限必须大于或等于父类方法的权限 public>protected>default
重写的方法返回值类型，必须与被重写方法的返回值类型一样 或者范围更小
私有方法，静态方法不能被重写，重写会报错
声明不变 重新实现
使用场景：子类重写 object 的类的 tostring 方法 以便返回对象的内容

子类构造器
子类的全部构造器，都会先调用父类的构造器，再执行自己的构造器，如果想要调用父类的构造器，必须使用 super 关键字
默认情况下，子类全部构造器的第一行代码都是 super（） 写不写都有，他会调用父类的无参数构造器，
如果父类没有无参数构造器 则我们必须再子类构造器的第一行写 super 指定去调用父类的有参数构造器

this 调用兄弟构造器, super 必须写再构造器的第一行，而且不能同时出现

多态： 在继承/实现情况下的一种对象，表现为 对象多态，行为多态 （未完成）

final 关键字 最终的意思 修饰 类 方法 变量
修饰类： 最终类，特点就是不能在被继承了 一般来说工具类都不用 final 修饰
修饰方法： 方法被称为最终方法，特点是不能在被重写了
修饰变量：该变量有且仅能被赋值一次, final 修饰静态变量 这个变量今后被称为常量，可以记住一个固定值，并且程序中不能修改了， 同城这个值作为系统的配置信息

单例模式 (需要学完)：确保某一个类只能创建一个对象 例如任务管理器 只需要一个实例就行

public class A{
private static A a = new A()

    private A(){}

    public static A getObject(){
        return a
    }

}

枚举类： 是一种特殊类， 都是 final 类 不能被继承
第一行之只能罗列一些名称，这些名称都是常量，并且每一个常量会记住枚举类的一个对象
枚举类的构造器都是私有的 因此对外不能创建对象

常见应用场景：很适合做信息分类和标志， 这个东西让他我想到了 js js 中例如在做信息分类 如：定义一个 bug 的状态 5 种状态，ticket 六种状态 其实用的也都是 enum 这个做法
如果使用枚举类会约束 输入值 只能限制在枚举类中定义的常量中
修饰符 enum 枚举类名{
名称 1,名称 2...
其他成员
}

抽象类 没有学习

接口:java 提供了一个关键字 interface 定义出接口，接口中的所有成员都是常量，并且都是 public static final 修饰的，接口中的方法都是抽象方法，抽象方法没有方法体，
并且不能创建对象，
public interface 接口名{
String test = "test";
}
接口是用来被类实现(implements)的 实现接口的类称为实现类，一个类可以同时实现多个接口
实现类要实现多个接口，必须重写完全部接口的全部抽象方法

修饰符 class 实现类 implements interface1, interface2...{

}
接口的好处： 弥补了类单继承的不足，一个类可以同时实现多个接口，使类的角色更多，功能更强大
让程序可以面向接口编程，这样程序员可以灵活方便切换各种业务的实现，更利于程序解耦

泛型：定义类，接口，方法时 同时声明了一个或多个类型变量 如 <E>
称为泛型类 泛型接口，泛型方法。
泛型提供了在编译阶段约束所能操作的数据类型，并自动检查的能力，这样可以避免强制类型转换 以及可能出现的异常
泛型的本质 把具体的数据类型作为参数 传给类型变量

泛型类
public class GenericClass<E>{
} //泛型字母一般使用 E T K V , E:代表一个元素， T 代表返回值， K 键名 V 值

关于类型声明 特别是针对 ArrayList array 类型的声明 例如这个 MyArryList<String> list = new MyArryList<>();
不要想的那么复杂 他就是创建了一个 list 对象， 这个对象是 myarrlist 的实例，并且这个对象有泛型，这个泛型是 string，

泛型接口
public interface GenericInterface<E>{
}
本质上 我理解的更像是做一种通用的数据接口 interface

泛型方法
public static <T> void test(T t){}

通配符
就是 ? 可以在 使用泛型的时候代表一切类型， ETKV 是在定义泛型的时候使用 但是在日常使用过程中会出现一个问题 不规定一个泛型的设计会导致其他乱七八糟的东西也使用这个泛型方法，
所以需要设置一个界限，叫泛型的上下限，
泛型上限， ? extends Car: ?能接收的必须是 Car 或者其他子类
泛型下限： ？ super Car ? 能接收的必须是 Car 或者其他父类

泛型不支持基本数据类型(int boolean long double float byte short char)， 只能支持对象类型(引用数据类型,eg: array ,string, arrayList)
包装类，就是把基本数据类型包装成对象类型
byte Byte
short Short
int Integer
long Long
float Float
double Double
boolean Boolean
char Character

泛型方法中不能使用基本数据类型，只能使用包装类
Integer j = Integer.valueOf() //Integer.valueOf() 他会自动缓存了-128-127 如果在这个范围的值 将不会创建对象

自动装箱 自动拆箱
基本数据类型的数据可以直接包装成对象的数据 不需要额外做任何事情
Integer i = 110;
Integer j = 110;
System.out.println(i == j);

把字符串数值转换成对应的基本数据类型(很有用) 在平时的开发中 前端传过来一个字符串 "98" 后端需要转换成 int 类型

int i1 = Integer.parseInt("98");

认识集合

集合是一种容器，用来装数据 类似于数组 但集合的大小可变 开发中也非常有用 例如 ArrayList

Collection(单列集合) Map（双列集合）

collection:每个元素（数据）只包含一个值 添加的元素是有顺序 可重复 有索引 ，
map：每个集合包含了两个值 key,value 无序不重复 无索引

ArrayList<E> HashSet<E> 用的是最多的

collection 遍历方式之一 迭代器
迭代器是用来遍历集合的专用方式 数组没有迭代器 在 java 中迭代器的代表是 iterator
Iterator<String> it = names.iterator();
while (it.hasNext()) {
String name = it.next();
System.out.println(name);

增强for 循环
for (元素的数据类型 变量名 : 数组或者集合){

}

Lambda 表达式

并发修改异常问题： 遍历集合的同时又储存在增删集合元素的行为，可能出现业务异常 这种现象被称为并发修改异常问题
如果集合没有索引 只能使用迭代器来进行 遍历并删除 ， 增强for循环 只适合做遍历 不适合做遍历并修改的操作
如果集合支持索引，可以使用for 循环遍历 每删减数据后做i--  或者可以倒着遍历


linkedList  有序 可重复 有索引， 和arraylist 底层实现不同 适合的场景不同
arrayList 底层是数组， 适合增删操作， 适合随机访问， 适合迭代
linkedList 底层是链表， 适合增删操作， 适合迭代， 适合顺序访问


arraylist 基于数组存储数据  linkedList 基于链表存储数据 
数组的特点 查询速度快， 增删慢  查询数据通过地址值和索引定位 查询任意数据耗时相同， 而删除效率低， 可能要把后面很多的数据进行前移

链表是一个一个独立的节点组成的，节点在内存中是不连续的 每个节点包含下一个节点的地址 linkedList 是基于双链表实现的 但是对首尾元素进行增删改查速度是快的
linkedList 链表特点 增删快， 查询慢， 查询任意数据耗时相同， 删除数据耗时也相同， 查询数据通过地址值和索引定位

linkedList 应用场景之一 就是用来设计队列， 队列是先进先出， 队列的底层是链表， 队列的增删操作都是O(1) 只在首尾操作数据 linkedList实现更合适
linkedList 应用场景之二 就是用来设计栈， 栈是先进后出， 栈的底层是链表， 栈的增删操作都是O(1) 只在尾部操作数据 linkedList实现更合适



stream 流
用于操作集合或者数组的数据， stream流大量的结合了lambda语法风格来编程，功能强大 性能高效 代码简介 可读性好


