###图解http
#### 前言
关于http相关的概念一直都不是很明白，打算重新梳理复习一下http(s) 相关的计算机网络知识,通过这本书以及后续其他学习，由浅入深了解计算机网络

1. 网络基础tcp/ip
tcp/ip有着分层管理，并且从上到下分为四层:应用层、传输层、网络层、数据链路层。把tcp/ip 层次化是有好处的，如果互联网只有一个协议统筹，某个地方需要改变的时候 就必须把所有部分都替换掉，分层之后层层封装 只需要把有变动的改变就可以了，和我们封装代码的道理是相似的。
1.1 应用层， 应用层决定了向用户提供应用级服务通信的活动，这一层有各类通用的应用服务，ftp，http dns等
1.2 传输层，是应用层的下层，主要提供处于网络连接中的两台计算机之间的数据传输，再tcp传输层有两个不哦她那个的协议tcp(传输控制协议)),udp(用户数据报文),经典的问题,tcp三四握手 四次挥手 udp的缺点等等 
1.3 网络层(网络互连层),网络层用来处理再网络上流动的数据包，数据包是网络传输的最小数据单位，该层规定了通过怎样的路径(路由)到达对方计算机，典型的问题 ip 路由 等
1.4 链路层(数据链路层，网络接口层),用来处理连接网络的硬件部分

![](../src/imgs/图解http1.png)

tcp/ip协议进行网络通信时会通过分层顺序与对方进行通信，发送端从应用层往下走 服务端网上，反过来一样
，为了方便传输在传输层tcp把从应用收到的数据进行分割并在各个报文打上序号标记及端口号转发给网络层， 在网络层 增加作为通信目的地的mac地址 后转发给链路层。 在传输数据的过程中 每经过一层必定会呗打上一个该层所属的首部信息，反之在接收层层传输时，会逐层的吧首部去掉

2. ip tcp dns关系
  按层次分,ip属于网络层，ip协议的作用就是指明了两个地址，用来指向数据要传送的地址，就是地址ip,mac，ip地址指明了节点被分配到的地址，mac地址指的是网卡所属的固定地址，ip地址可以和mac地址进行配对，ip可以换，但是mac地址基本不会变。
  而数据数据的传送主要靠路由器或交换机进行分段传送。这个过程就是路由选择 

  3. tcp的三次握手 四次挥手
   按层次分 tcp 位于传输层，提供可靠的字节流服务(为了方便传输将大块数据分割成以报文段为单位的数据包进行管理，而可靠的传输服务是指数据可以准确的发送过去)，巍峨了准确将数据送到,tcp就用到了三次握手 四次挥手的功能了。握手过程中使用了tcp标志，flag syn(synchronize同步) ack(acknowledegment,确认)
   ![](../src/imgs/图解http2.png)

    第一次握手: 建立连接时，客户端发送sync包(x) 到服务器，并进入 syn_sent 同步请求状态 等待服务器确认
    第二次握手: 服务器收到sync包，必须确认客户的sync值(x+1)，同时自己发送一个sync包(y)， 此时服务器进入syn_recv状态
    第三次握手： 客户端收到服务器的syn，ack包，同时向服务器发送确认包ack(y+1)  证明客户端安全接受同步确认包 双方都进入  established状态 完成三次握手

    tcp的四次挥手

    因为tcp连接是全双工的，每个方向都要单独进行关闭，道理上就是 当一方完成数  据发送任务后，发送一个fin 来终止这一方向的链接，收到fin只是意味着这一方 向没有数据流动了，即不会收到数据了，但是这个tcp连接依然可以发送数据，直  到另一方也发送了fin，首先进行关闭的一方将执行主动关闭，而另一方则执行被 动关闭。

    第一次挥手 数据传输结束后，客户端的应用进程发出连接释放报文段fin=1, 并停止发送数据，其首部 fin=1 seq = u 这时候客户端还是可以接收数据的，

    第二次挥手 服务单收到连接释放报文段之后，发出确认报文 其首部 ack=u+1;seq =v; 此时本次连接就进入了半关闭状态，客户端不再向服务器发送数据。而服务器仍会继续发送

    第三次挥手 若服务器已经没有要向客户端发送的数据了，其应用进程就会释放tcp连接，这个阶段服务器所发出的最后一个报文的首部 应该是 fin=1; ack=1 seq=w ack=u+1

    第四次挥手 客户端收到连接释放报文段之后 必须发出 ack=1; seq=u+1;ack=w+1 在经过2msl（最长报文报文段寿命） 后 本次tcp连接真正结束 



 为什么不用两次握手?
 解：3次握手主要完成两个重要功能，既要双方做好发送数据的准备工作(双方都知道彼此已经准备好),也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认
  选择把三次握手改成两次，死锁可能发生的，考虑计算机客户端(c)和服务器(s)之间的通信,假设c给s发送一个连接请求，s收到了这个请求 并发送了确认应答，按照两次握手得协定，s认为连接已经成功了 便开始发送数据，可是c在s答应请求运输得情况下 如果出了问题那就会出现这样一种场景，c不知道s是否已经准备好，也不知道s建立了什么样得序列号，c甚至怀疑s是否收到了自己得请求，在这种情况下c认为连接还未建立成功，会忽略s发来得任何数据，只等连接确认 而s在发出得数据超时后会继续发重复得数据 这样就出了问题了。 c端不确认建立连接，中途如果收到其他得s发送得数据 没有办法回应，会出现丢数据得问题

 ![](../src/imgs/http3.png)


如果已经建立了链接 但是客户端发生了故障怎么办？
解： 客户端如果出现故障，服务器也不会一直等下去，服务器每收到一次客户端得请求后都会重新复位一个计时器，这个计时器通常设置为2h，2h之后还是没有收到客户端得任何数据，服务器就会发送一个探测报文段，以后每隔75s 发送一次 若是发送10个都没反应 那么就关闭了链接

tcp是面向连接的传输层协议 提供可靠的 全双工(接收和发送互不影响的，也就是我们平常说的上行速度和下行速度 像是打电话一样)，于此同时就是半双工 指的是一个时间段只能做一个动作，只能接收或者发送 


挥手为什么还要等2msl？ 
1.需要爆炸服务器收到了客户端收到了最后一条确认报文，假如这条报文丢失，服务器没有接收到确认报文，就会对连接释放报文进行超时重传，而此时客户端连接已经关闭，无法做出响应，就造成了服务器不停重传连接释放报文，而无法政策进入关闭状态状况，而等2msl 就可以保证服务器收到了最终确认，若服务器端没有收到，那么在2msl内客户端一定会收到服务器的重传报文 此时客户端就会重传确认报文，并重置计时器

为什么三次握手 四次挥手？

服务器端在listen状态下 收到建立连接请求的syn报文后， 把ack syn 放在一个报文段里发送给客户端，而关闭时 当收到了对方的fin时候 因为是双工的 他仅仅表示对方不在发送数据了 但是还能接收数据，而且己方也未必全部数据都发送给对方了，所以己方在可以检查一下应用层之后 如果没有数据可以发送了 就可以发送fin报文 来表示给地方同意了 关闭现在的链接 因此己方的ack 和fin都会分开发送


TCP UDP 的区别
1. 基于有连接和无连接，udp是无连接的 叫广播 发送数据不用建立连接 是不稳定的 有丢包的可能，tcp保证数据的准确性 tcp保证数据有顺序 udp有良好的实时性 效率比tcp高，使用对告诉传输和实时性有较高的通信或广播通信



 seq(序号):tcp连接字节流中每一个字节都会有一个编号，而本字段的值指的是本报文段所发送数据部分第一个字节的序号

 ack(确认号): 表示期望收到的下一个报文数据部分的第一个字节的编号，编号为ack-1即以前的字节已经收到 收到相应的数据了

 SYN(确认号): 当本字段为1 时 表示这是一个连接请求或者连接接受的报文
 ACK: 仅当字段为1 时 确认号才有效，acknowledge 同步确认
 FIN: 用来释放一个连接，当字段为1的时候，表示此报文段的发送端数据已经发送完毕，要求释放连接，注意因为tcp是双工的 所以才有这个 






感谢其他链接的分享
https://cloud.tencent.com/developer/news/257281
https://cloud.tencent.com/developer/news/257281