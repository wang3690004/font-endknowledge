###前端模块化&&懒加载&&按需加载
模块化开发方式是前端工程化的一个必须操作，可以提高代码复用率方便管理，通常一个文件就是一个模块有自己的作用域，目前模块化方案主要有如下几种:commonjs amd cmd(前三种是es5提供的)，还有es6模块系统 import/export
1.amd规范: 异步模块定义，amd不是js原生支持，他是requirejs在推广过程中对模块定义的范围化的产出，所以使用amd规范进行页面开发需要用到对应的库 也就是requirejs,(貌似没人用这个了都用es6的)
requirejs 解决了两个问题：1.多个js文件存在依赖关系时，被依赖的文件需要遭遇依赖他的文件加载到服务器  2.js加载的时候浏览器会阻塞渲染线程 加载文件越多 页面失去响应的时间越长

2.cmd规范： 通用模块定义，cmd是在seajs推广中产生的是一个同步模块定义，在cmd规范中一个模块就是一个文件 cmd依赖就近 在什么地方使用到插件就在什么地方require该插件 
两者的比较 {
    定义module时对依赖的处理：
    amd: 推崇依赖前置，在定义的时候就要声明其依赖的模块
    cmd：推崇就近依赖，只有在用到这个module时候采取require

    加载方式：
    amd：异步
    cmd：同步

    执行module方式:
    amd:amd加载module完成后就会执行该module 所有module都加载执行完成后会进入require回调函数，执行主逻辑，依赖的执行顺序和书写的顺序不一定一致，谁先下载完成谁就先执行，但是主逻辑一定在所有的依赖加载完成后才执行 有点像promise。all
    cmd:加载某个依赖后并不执行，只是下载而已，在所有的module加载完成后进入主逻辑，遇到require语句的时候才会执行对应的module，module执行顺序和书写的顺序完全一致
}




1. commonjs : nodejs是commonjs规范的主要实践者，主要用require, commonjs的模块是对象 输入时必须查找对象属性,一般做法是运行时加载 只有运行时才能得到对象 不能在编译时做到静态化
```
let {stat,exists} = require('fs')
等价于
let _fs = require('fs')
let stat = _fs.stat,
let exists = _fs.exists
```

2. es6 模块不是对象 而是通过export 命令显示指定输出代码，再通过import 输入，在编译的过程中导入
```
import {stat,exists} from 'fs'   //从fs加载stat exists  其他不加载
```
3. export 模块是独立的文件 该文件内部的所有的变量外部都无法获取，如果希望获得某个变量 必须用export, 
```
export let firstname = 'dddd'  
export let lastname = 'aaaa'
export {firstname,lastname}
export function test(){}
import {let} from '..'

```

4. import适用于场合 : 
   1.按需加载
   ```
   button.addEventListener('click',event=>{
       import('./dialog.js')  //感觉这更像是导入国际化语言的一种方法。就是利用了按需加载的做法
   }).then(dialog=>{
       dialog.open()
   })
   ```


lodash 等按需引入 
感谢以下链接分享：
https://www.cnblogs.com/sunidol/p/11306283.html
http://www.imooc.com/article/19828
https://www.cnblogs.com/liaojie970/p/7376682.html