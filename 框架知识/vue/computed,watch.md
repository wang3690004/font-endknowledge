####computed,watch区别以及一些日常使用的场景
1. computed 更多的是用来监控自己定义的变量，该变量不在data里面声明，直接在computed里面定义，更像是把一些data里面的处理结果做一个缓存同时随时响应到页面上，并使用双向绑定展示结果。
2. computed 比较适合对多个变量或者对象进行处理返回一个结果值，也就是多个变量某一个值发生了变化，都会影响监控的属性，举一个例子购物车的总金额就是一个比较好的例子
3. 具体写法： 和data methods watch同级放在导出对象中
 ```
 computed:{ ///他是一个对象,并且language不能是实例属性
    language(){
        return this.locale
    }
 }
 ```
4. 假设我们有一个性能开销比较大的计算属性a，他需要遍历一个极大的数组和做大量的计算，然后我们可能有其他的计算属性依赖于a，如果没有缓存不可避免要多次执行getter，
5. watch watch还是会影响性能的 不要滥用它，如果有其他可以替代还是尽量不使用他，基本用法就是
```
watch:{
    value(newval,oldvalue){
        this.visible = value
    } // 他也是一个对象，并且这里的value是实力属性，不然也没有办法监听了。
}
``` 
6. immediate和handler 使用watch有一个特点，就是当值第一次绑定的时候不会执行监听函数，只有值改变才会发生执行，如果我们需要在最初绑定值的时候也执行函数，则需要用到immediate属性
比如当父组件向子组件动态传值的时候，子组件props 首次获取到父组件传来的默认值时，也需要执行函数，此时将immediate设置为true，
如果想要监听对象属性需要设置deep属性，他可以监听对象属性值的变化，不过当属性较多的时候每个属性发生变化都会执行handler，这样就不好了，如果值需要监听对象中的一个属性值，则可以做以下的优化，使用字符串的形式监听对象属性
```
watch:{
    'city.name':{
        handler(new,old){},
        deep:true,
        immdiate:true    
    }
} //这样可以给对象的某一个属性添加监听器，同时数组的变化不需要深度监听，对象书中对象的属性需要deep监听
```

与watch之间的区别：
watch主要监控vue的实例属性的变化，她是我们平常认知中的监听，即监听某一个事先设置好的属性，这个属性发生任何变化 都会触发相应的回调函数。她可以监听一个变量 也可以监听一个对象，



感谢下面链接的分享：
https://www.cnblogs.com/gunelark/p/8492468.html
https://www.cnblogs.com/shiningly/p/9471067.html