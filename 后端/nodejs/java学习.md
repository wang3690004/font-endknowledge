数组定义
String [] names = {"1","2","3","4"} 静态定义数组
double [] scores = new double[8] 动态定义数组

构造器
public class Student{
}
//在类中 设置一个方法名与类名一致且不返回任何值，
构造器创建对象时 对象会去调用构造器 创建对象时完成对对象成员变量初始化赋值
类默认自带一个无参数构造器，如果定义了有参构造器，类默认的无参构造器就没有了，此时如果还想用无参构造器 就必须手写一个

this 关键字
this 就是一个变量 可在方法中 来拿到当前的对象
使用场景： 解决变量名称冲突问题

封装 继承 多态
面向对象的三大特征， 类就是一种封装
封装：合理隐藏 合理暴露
private : 关键字修饰成员变量，就只能在本类中被直接访问 其他任何地方不能直接访问

实体类： 类中的成员变量全部私有，并提供 getter setter 方法
类中需要提供一个无参数的构造器 有参数构造器可选
实体类 javabean 的基本作用：
实体类的应用场景： 实体类的对象 只负责数据存取，而对数据业务处理交给其他类的对象来完成，以实现数据和数据业务处理相分离
public clss Student{
name,age,
}

public class StudentOperator{
private Student s;
public StudentOperator(Student s){
this.s = s
}
}

static 关键字 可以修饰成员变量 成员方法
public class Student{
static String name;  
}
成员变量按照有无 static 修饰分为两种
静态变量（类变量）有 static 修饰 属于类变量 在计算机里只有一份 会被类的全部对象共享
实例变量（对象的变量）无 static 修饰 属于每一个对象的但是彼此不共享

static 静态方法 如果这个方法只是为了做一个功能不需要直接访问对象的数据，这个方法直接定义成静态方法
如果这个方法是对象的行为，需要访问对象的数据 这个方法必须定义成实例方法，
常见的应用场景： 工具类，工具类中的方法一般都是静态方法，每个方法都要来完成一个功能以便给开发人员直接使用
静态方法 中可以访问静态变量，但是不能访问实例变量
实例方法中既可以直接访问静态变量，也可以直接访问实例变量
实例方法中可以出现 this 关键字 静态方法中不可以出现 this 关键字

什么是继承
java 中提供了一个关键字 extends 这个可以让一个类和另一个类建立起父子关系， A 成为父类 B 成为子类
public class B extends A{

}
子类能继承父类的非私有成员（成员变量 成员方法）
继承后对象的创建，子类的对象是由子类 父类共同完成的

权限修饰符
private 只能本类
缺省 本类、同一个包中的类
protected 本类、同一个包中的类、子类
public 所有
使用标准， 一般的成员变量 一般都是使用 private 方法一般都会 public 至于缺省 protected 根据业务需求

java 单继承 只能有一个父类 不支持多继承，但是支持多层继承，如 爷 父 子类

java 类为什么不支持多继承 如果一个子类 又继承了 A 又继承了 B 都是父类 如果两个父类都有同一个方法 那么子类调用这个方法的时候就无法确定调用的是哪个父类的方法 所以不支持多继承

java 中的祖宗类 Object， java 所有的类 要么直接继承了 Object 要不默认继承了 object 要么间接继承了 object，

继承后子类访问成员的特点 ：就近原则 子类中如果有同名成员变量，访问子类中同名成员变量，如果没有同名成员变量，访问父类中同名成员变量
可以使用 super 关键字 访问父类的成员 super.成员变量 super.方法名

方法重写： 当子类觉得父类中的某个方法不好用 可以重写这个方法，参数列表一样的方法去覆盖父类的这个方法 就是方法重写，最好给方法重写添加一个 注解 @Override 告诉别人这是个重写的方法 要求方法名称 形参 必须和被重写的方法一致
需要注意的是 子类重写父类方法时 访问权限必须大于或等于父类方法的权限 public>protected>default
重写的方法返回值类型，必须与被重写方法的返回值类型一样 或者范围更小
私有方法，静态方法不能被重写，重写会报错
声明不变 重新实现
使用场景：子类重写 object 的类的 tostring 方法 以便返回对象的内容

子类构造器
子类的全部构造器，都会先调用父类的构造器，再执行自己的构造器，如果想要调用父类的构造器，必须使用 super 关键字
默认情况下，子类全部构造器的第一行代码都是 super（） 写不写都有，他会调用父类的无参数构造器，
如果父类没有无参数构造器 则我们必须再子类构造器的第一行写 super 指定去调用父类的有参数构造器

this 调用兄弟构造器, super 必须写再构造器的第一行，而且不能同时出现

多态： 在继承/实现情况下的一种对象，表现为 对象多态，行为多态  （未完成）

final 关键字 最终的意思 修饰 类 方法 变量
修饰类： 最终类，特点就是不能在被继承了 一般来说工具类都不用 final 修饰
修饰方法： 方法被称为最终方法，特点是不能在被重写了
修饰变量：该变量有且仅能被赋值一次, final 修饰静态变量 这个变量今后被称为常量，可以记住一个固定值，并且程序中不能修改了， 同城这个值作为系统的配置信息

单例模式 (需要学完)：确保某一个类只能创建一个对象 例如任务管理器 只需要一个实例就行

public class A{
private static A a = new A()

    private A(){}

    public static A getObject(){
        return a
    }

}



枚举类：  是一种特殊类， 都是final类 不能被继承
第一行之只能罗列一些名称，这些名称都是常量，并且每一个常量会记住枚举类的一个对象
枚举类的构造器都是私有的 因此对外不能创建对象

常见应用场景：很适合做信息分类和标志， 这个东西让他我想到了js js中例如在做信息分类 如：定义一个bug 的状态 5种状态，ticket 六种状态 其实用的也都是enum这个做法
如果使用枚举类会约束 输入值 只能限制在枚举类中定义的常量中
修饰符 enum 枚举类名{
    名称1,名称2...
    其他成员
}

抽象类 没有学习

接口:java 提供了一个关键字interface 定义出接口，接口中的所有成员都是常量，并且都是 public static final 修饰的，接口中的方法都是抽象方法，抽象方法没有方法体，
并且不能创建对象，
public interface 接口名{
    String test = "test";
}
接口是用来被类实现(implements)的 实现接口的类称为实现类，一个类可以同时实现多个接口
实现类要实现多个接口，必须重写完全部接口的全部抽象方法

修饰符 class 实现类 implements interface1, interface2...{

}
接口的好处： 弥补了类单继承的不足，一个类可以同时实现多个接口，使类的角色更多，功能更强大
让程序可以面向接口编程，这样程序员可以灵活方便切换各种业务的实现，更利于程序解耦


泛型：定义类，接口，方法时 同时声明了一个或多个类型变量 如 <E>
称为泛型类 泛型接口，泛型方法。
泛型提供了在编译阶段约束所能操作的数据类型，并自动检查的能力，这样可以避免强制类型转换 以及可能出现的异常
泛型的本质 把具体的数据类型作为参数 传给类型变量